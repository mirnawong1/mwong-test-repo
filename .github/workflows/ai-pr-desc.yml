name: AI PR Description (test)

on:
  pull_request_target:
    types: [opened, reopened, ready_for_review, synchronize]
  issue_comment:
    types: [created]

permissions:
  contents: read
  pull-requests: write
  issues: read

jobs:
  generate:
    runs-on: ubuntu-latest
    steps:
      - name: Generate or update PR description
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          GITHUB_MODELS_TOKEN: ${{ github.token }}
        with:
          script: |
            const MARKER_START = '<!-- ai-pr-desc:start -->';
            const MARKER_END = '<!-- ai-pr-desc:end -->';
            const MODEL = 'gpt-4o-mini';
            const MAX_DIFF_CHARS = 15000;

            // Determine PR number (PR event or /regen-pr-desc comment)
            let pull_number = null;
            if (context.eventName === 'pull_request_target') {
              pull_number = context.payload.pull_request.number;
            } else if (context.eventName === 'issue_comment') {
              if (!context.payload.issue.pull_request) return;
              const body = (context.payload.comment.body || '').toLowerCase();
              if (!body.includes('/regen-pr-desc')) return;
              pull_number = context.payload.issue.number;

              // Allow PR author or collaborators with write/admin
              const commenter = context.payload.comment.user.login;
              const { data: prForPerm } = await github.rest.pulls.get({ ...context.repo, pull_number });
              const isAuthor = commenter === prForPerm.user.login;
              let hasWrite = false;
              try {
                const { data: perm } = await github.rest.repos.getCollaboratorPermissionLevel({
                  ...context.repo, username: commenter
                });
                hasWrite = ['admin','write','maintain'].includes(perm.permission);
              } catch {}
              if (!isAuthor && !hasWrite) {
                core.notice('Commenter lacks permission to regenerate.');
                return;
              }
            } else {
              return;
            }

            const { owner, repo } = context.repo;
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number });

            // List changed files (no checkout; safe for forks)
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner, repo, pull_number, per_page: 100
            });
            if (!files.length) {
              core.notice('No changed files on PR.');
              return;
            }

            const fileSummaries = files.map(f => {
              const line = `- ${f.filename} (${f.status}, +${f.additions}/-${f.deletions})`;
              const patch = f.patch || '';
              const trimmed = patch.length > 2000 ? patch.slice(0, 2000) + '\n[patch trimmed]' : patch;
              return { basic: line, patch: trimmed };
            });
            const fileListText = fileSummaries.map(s => s.basic).join('\n');

            let diffsText = '';
            for (const s of fileSummaries) {
              const next = `\n\n---\n${s.basic}\n${s.patch}`;
              if ((diffsText + next).length > MAX_DIFF_CHARS) {
                diffsText += `\n\n[additional diffs trimmed due to size]`;
                break;
              }
              diffsText += next;
            }

            const prompt = `You are an expert technical writer drafting PR descriptions for a public Docusaurus docs repo.
            Write a concise, editable PR description:
            - Start with a single-sentence summary.
            - Then 5â€“10 bullets: what changed, why, notable pages/sections, key files, reviewer checklist.
            - Neutral tone; do not invent beyond provided context.
            PR title: ${pr.title}
            Branch: ${pr.head.ref}
            Files changed:
            ${fileListText}
            Sample diffs (truncated):
            ${diffsText}
            `.trim();

            async function callOpenAI(prompt) {
              if (!process.env.OPENAI_API_KEY) return '';
              try {
                const r = await fetch('https://api.openai.com/v1/chat/completions', {
                  method: 'POST',
                  headers: {
                    'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    model: MODEL,
                    temperature: 0.3,
                    max_tokens: 700,
                    messages: [
                      { role: 'system', content: 'You write concise, high-quality PR descriptions for documentation changes.' },
                      { role: 'user', content: prompt }
                    ]
                  })
                });
                if (!r.ok) {
                  core.notice(`OpenAI call failed: ${await r.text()}`.slice(0, 500));
                  return '';
                }
                const j = await r.json();
                return j.choices?.[0]?.message?.content?.trim() || '';
              } catch (e) {
                core.notice(`OpenAI error: ${String(e).slice(0, 300)}`);
                return '';
              }
            }

            async function callGitHubModels(prompt) {
              if (!process.env.GITHUB_MODELS_TOKEN) return '';
              try {
                // GitHub Models (OpenAI-compatible). Requires org/account enablement.
                const r = await fetch('https://models.inference.ai.azure.com/openai/deployments/gpt-4o-mini/chat/completions?api-version=2024-06-01', {
                  method: 'POST',
                  headers: {
                    'Authorization': `Bearer ${process.env.GITHUB_MODELS_TOKEN}`,
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    temperature: 0.3,
                    max_tokens: 700,
                    messages: [
                      { role: 'system', content: 'You write concise, high-quality PR descriptions for documentation changes.' },
                      { role: 'user', content: prompt }
                    ]
                  })
                });
                if (!r.ok) {
                  core.notice(`GitHub Models call failed: ${await r.text()}`.slice(0, 500));
                  return '';
                }
                const j = await r.json();
                return j.choices?.[0]?.message?.content?.trim() || '';
              } catch (e) {
                core.notice(`GitHub Models error: ${String(e).slice(0, 300)}`);
                return '';
              }
            }

            function buildFallbackDescription() {
              const checklist = [
                '- [ ] Pages render locally (Docusaurus build passes)',
                '- [ ] Links resolve (no broken anchors)',
                '- [ ] Technical accuracy verified',
                '- [ ] Style/tone aligns with docs guidelines'
              ].join('\n');

              return [
                'Summary: Documentation updates based on the files below.',
                '',
                'Changes:',
                fileListText,
                '',
                'Reviewer checklist:',
                checklist
              ].join('\n');
            }

            // Try OpenAI first; if quota/misconfig, fall back to GitHub Models; else static template
            let aiText = await callOpenAI(prompt);
            if (!aiText) {
              aiText = await callGitHubModels(prompt);
            }
            if (!aiText) {
              core.notice('Both LLM providers unavailable; using fallback template.');
              aiText = buildFallbackDescription();
            }

            const aiSection = `${MARKER_START}\n\n${aiText}\n\n${MARKER_END}`;
            const existingBody = pr.body || '';
            let newBody;

            if (!existingBody) {
              newBody = aiSection + '\n\n' +
                '_Note: This AI Suggested Description is editable. Use `/regen-pr-desc` to refresh._';
            } else if (existingBody.includes(MARKER_START) && existingBody.includes(MARKER_END)) {
              newBody = existingBody.replace(
                new RegExp(`${MARKER_START}[\\s\\S]*?${MARKER_END}`),
                aiSection
              );
            } else if (context.eventName === 'pull_request_target' &&
                       ['opened','reopened','ready_for_review'].includes(context.payload.action)) {
              newBody = existingBody + '\n\n' + aiSection;
            } else if (context.eventName === 'issue_comment') {
              newBody = existingBody + '\n\n' + aiSection;
            } else {
              core.notice('PR body exists without AI markers; skipping update.');
              newBody = null;
            }

            if (newBody !== null) {
              await github.rest.pulls.update({ owner, repo, pull_number, body: newBody });
              core.info('PR description updated.');
            }

            // Optional Slack ping
            if (process.env.SLACK_WEBHOOK_URL) {
              const prUrl = pr.html_url;
              const text = `PR review request: ${pr.title}\n${prUrl}\n\nAI summary:\n${aiText}`;
              try {
                await fetch(process.env.SLACK_WEBHOOK_URL, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ text })
                });
              } catch (e) {
                core.notice(`Slack post failed: ${String(e).slice(0, 300)}`);
              }
            }
