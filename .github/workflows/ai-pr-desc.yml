name: AI PR Description (test)

on:
  pull_request_target:
    types: [opened, reopened, ready_for_review, synchronize]
  issue_comment:
    types: [created]

permissions:
  contents: read
  pull-requests: write
  issues: read

jobs:
  generate:
    runs-on: ubuntu-latest
    steps:
      - name: Generate or update PR description
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          script: |
            const MARKER_START = '<!-- ai-pr-desc:start -->';
            const MARKER_END = '<!-- ai-pr-desc:end -->';
            const MODEL = 'gpt-4o-mini';
            const MAX_DIFF_CHARS = 15000;

            if (!process.env.OPENAI_API_KEY) {
              core.notice('OPENAI_API_KEY not set; skipping.');
              return;
            }

            // Determine PR number (PR event or /regen-pr-desc comment)
            let pull_number = null;
            if (context.eventName === 'pull_request_target') {
              pull_number = context.payload.pull_request.number;
            } else if (context.eventName === 'issue_comment') {
              if (!context.payload.issue.pull_request) return;
              const body = (context.payload.comment.body || '').toLowerCase();
              if (!body.includes('/regen-pr-desc')) return;
              pull_number = context.payload.issue.number;

              // Allow PR author or collaborators with write/admin
              const commenter = context.payload.comment.user.login;
              const { data: prForPerm } = await github.rest.pulls.get({ ...context.repo, pull_number });
              const isAuthor = commenter === prForPerm.user.login;
              let hasWrite = false;
              try {
                const { data: perm } = await github.rest.repos.getCollaboratorPermissionLevel({
                  ...context.repo, username: commenter
                });
                hasWrite = ['admin','write','maintain'].includes(perm.permission);
              } catch {}
              if (!isAuthor && !hasWrite) {
                core.notice('Commenter lacks permission to regenerate.');
                return;
              }
            } else {
              return;
            }

            const { owner, repo } = context.repo;
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number });

            // List changed files (no checkout; safe for forks)
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner, repo, pull_number, per_page: 100
            });
            if (!files.length) {
              core.notice('No changed files on PR.');
              return;
            }

            const fileSummaries = files.map(f => {
              const line = `- ${f.filename} (${f.status}, +${f.additions}/-${f.deletions})`;
              const patch = f.patch || '';
              const trimmed = patch.length > 2000 ? patch.slice(0, 2000) + '\n[patch trimmed]' : patch;
              return { basic: line, patch: trimmed };
            });
            const fileListText = fileSummaries.map(s => s.basic).join('\n');

            let diffsText = '';
            for (const s of fileSummaries) {
              const next = `\n\n---\n${s.basic}\n${s.patch}`;
              if ((diffsText + next).length > MAX_DIFF_CHARS) {
                diffsText += `\n\n[additional diffs trimmed due to size]`;
                break;
              }
              diffsText += next;
            }

            const prompt = `
You are an expert technical writer drafting PR descriptions for a public Docusaurus docs repo.

Write a concise, editable PR description:

- Start with a single-sentence summary.
- Then 5â€“10 bullets: what changed, why, notable pages/sections, key files, reviewer checklist.
- Neutral tone; do not invent beyond provided context.

PR title: ${pr.title}
Branch: ${pr.head.ref}
Files changed:
${fileListText}

Sample diffs (truncated):
${diffsText}
            `.trim();

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                model: MODEL,
                temperature: 0.3,
                max_tokens: 700,
                messages: [
                  { role: 'system', content: 'You write concise, high-quality PR descriptions for documentation changes.' },
                  { role: 'user', content: prompt }
                ]
              })
            });
            if (!response.ok) {
              core.setFailed(`LLM call failed: ${await response.text()}`);
              return;
            }
            const data = await response.json();
            const aiText = data.choices?.[0]?.message?.content?.trim();
            if (!aiText) {
              core.setFailed('No content returned from model.');
              return;
            }

            const aiSection = `${MARKER_START}\n\n${aiText}\n\n${MARKER_END}`;
            const existingBody = pr.body || '';
            let newBody;

            if (!existingBody) {
              newBody = aiSection + '\n\n' +
                '_Note: This AI Suggested Description is editable. Use `/regen-pr-desc` to refresh._';
            } else if (existingBody.includes(MARKER_START) && existingBody.includes(MARKER_END)) {
              newBody = existingBody.replace(
                new RegExp(`${MARKER_START}[\\s\\S]*?${MARKER_END}`),
                aiSection
              );
            } else if (context.eventName === 'pull_request_target' &&
                       ['opened','reopened','ready_for_review'].includes(context.payload.action)) {
              newBody = existingBody + '\n\n' + aiSection;
            } else if (context.eventName === 'issue_comment') {
              newBody = existingBody + '\n\n' + aiSection;
            } else {
              core.notice('PR body exists without AI markers; skipping update.');
              newBody = null;
            }

            if (newBody !== null) {
              await github.rest.pulls.update({ owner, repo, pull_number, body: newBody });
              core.info('PR description updated.');
            }

            // Optional Slack ping
            if (process.env.SLACK_WEBHOOK_URL) {
              const prUrl = pr.html_url;
              const text = `PR review request: ${pr.title}\n${prUrl}\n\nAI summary:\n${aiText}`;
              try {
                await fetch(process.env.SLACK_WEBHOOK_URL, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ text })
                });
              } catch (e) {
                core.notice(`Slack post failed: ${String(e)}`);
              }
            }
